\babel@toc {english}{}
\contentsline {figure}{\numberline {1}{\ignorespaces Illustration of the QSAR/QSPR workflow using ML/DL. Reprinted from \cite {yangMPP}. \relax }}{1}{figure.caption.1}%
\contentsline {figure}{\numberline {2}{\ignorespaces Molecular graph of sulfuric acid.\relax }}{4}{figure.2}%
\contentsline {figure}{\numberline {3}{\ignorespaces Adjacency matrix of the molecular graph representing sulfuric acid given the node ordering.\relax }}{4}{figure.3}%
\contentsline {figure}{\numberline {4}{\ignorespaces Example feature matrix of the graph in Figure \ref {fig:mol_graph}. The first two columns encode the atom type and the last two columns are a one-hot encoding of the number of implicit hydrogen atoms.\relax }}{4}{figure.4}%
\contentsline {figure}{\numberline {5}{\ignorespaces Example edge feature matrix of the graph in Figure \ref {fig:mol_graph}. The chosen features represent a one-hot encoding of the bond type.\relax }}{4}{figure.5}%
\contentsline {figure}{\numberline {6}{\ignorespaces Illustration of the iterative updating in the computation of the ECFPs. In this example the atom type is used as an identifier. In iteration 0 the middle atom' identifier only represents the information about its own type. After the first iteration it has aggregated the information from its immediate neighbors and after the second iteration the represented substructure has grown even further. Reprinted from \cite {ECFP}. \relax }}{5}{figure.caption.3}%
\contentsline {figure}{\numberline {7}{\ignorespaces Molecular graphs obtained using the code in Appendix \ref {sec:a_sim}.\relax }}{6}{figure.caption.4}%
\contentsline {figure}{\numberline {8}{\ignorespaces Molecular graphs obtained using the code in Appendix \ref {sec:a_sim}.\relax }}{6}{figure.caption.5}%
\contentsline {figure}{\numberline {9}{\ignorespaces Illustration of the message passing in a MPNN. Reprinted from \cite {mpnn_graphics}. \relax }}{7}{figure.caption.7}%
\contentsline {figure}{\numberline {10}{\ignorespaces Comparison of the algorithm that generated circular fingerprints with that for generating neural graph fingerprints. Note that the left algorithm uses the interpretation of the atom's hashed identifiers as indices of bits in an array as explained in section \ref {sec:circ_finger}. Reprinted from \cite {duvenaud2015convolutional}. \relax }}{8}{figure.caption.8}%
\contentsline {figure}{\numberline {11}{\ignorespaces Comparison of the root-mean-square error on the three data set mentioned above for circular fingerprints and neural fingerprints (GNN). Reprinted from \cite {duvenaud2015convolutional}. \relax }}{9}{figure.caption.9}%
\contentsfinish 
